---
layout: main
---
<div class="container">
  <div class="row">
    <a class="button plain u-pull-right" href="https://www.github.com/sedstrom/Witch-Android">
      GITHUB
    </a>
    <!--<a class="button plain u-pull-right right-20" href="https://www.github.com/sedstrom/Witch-Android-Samples">
      EXAMPLES
      -->
    </a>
  </div>
</div>
<div class="section">
  <div class="container">
    <div class="row">
      <ul class="twelve columns logo">
        <li>
          <img src="assets/img/logo-icon-font.svg"/>
        </li>
        <li class="top-70">
          <h1 id="headline">
            View-data binding on <span class="accent-color">Android</span>
          </h1>
        </li>
      </ul>
    </div>
    <div class="row">
      <div class="twelve columns">
          <p id="introduction">
            Use annotations to bind data to views without any view lookup.
            Sync all view data in one go and keep view states up to date with
            application state at all times. View holders are bulit in.
          </p>
      </div>
    </div>
    <div class="row top-50 bottom-30">
      <a class="button offset-by-four four columns" href="#install">
        Get started!
      </a>
    </div>
  </div>
</div>
<div class="section divider-top">
  <div class="container top-30">
    <!-- Introduction -->
    <div class="row">
      <div class="twelve columns">
          <h2>
            Why Witch?
          </h2>
          <p>
            Witch is a light weight and performant view-data binding framework that helps building predictable UI:s.
            <br/><br/>
            Unlike the <a href="https://developer.android.com/topic/libraries/data-binding/">Data binding library</a> that is part of jetpack, there are no bindings declared in the layout xml and there are no binding adapters. 
            Witch has less ceremony, is simpler to use and dictates no underlying architecture.
          </p>
      </div>
    </div>
    <!-- Binder -->
    <div class="row">
      <div class="twelve columns">
          <h2>
            Binder
          </h2>
          <p>
            A binder (or whatever you may call it) is the core class you need to define in order to bind data to views. It's just a plain class
            with annotations declaring data and bindings. Below is a small example of a binder binding a user model to a text view:
          </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/binder.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/binder.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Execute binding -->
    <div class="row">
      <div class="twelve columns">
        <h2>
          Execute binding
        </h2>
        <p>
          Data is bound when a binder and a view (or an activity) is passed to <b>Witch.bind()</b>.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/bind-to-view.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/bind-to-view.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Data -->
    <div class="row">
      <div class="twelve columns">
        <h2>
          @Data
        </h2>
        <p>
          The @Data-annotation is used to declare data properties. Only data properties can be used in bind methods. Each time a binder is passed to Witch.bind()
          the data properties will evaluated. Only properties that has changed since last bind will be bound. 
          <br/><br/>
          In the above example, the entire user model is declared a data property despite only the user name is bound to a view. 
          This might be OK in some cases, but if the user model is frequently updated, the name will be repeatedly bound without being changed.
          Since the @Data-annotation can be used on methods, we can create a data property just for the user name. This way the name is only bound 
          when actually changed.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/data.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/data.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Bind -->
    <div class="row">
      <div class="twelve columns">
        <h2>
          @Bind
        </h2>
        <p>
          The @Bind-annotation is used to declare bind methods. This is how data gets bound to a view. The view is looked up (once) with the id defined in the annotation.
          Data passed to the bind method is mapped using type and name of any data property in the same class.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/bind.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/bind.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- BindData-->
    <div class="row">
      <div class="twelve columns">
        <h2>
          @BindData
        </h2>
        <p>
          If a binding is simply setting data on a view the @Data and @Bind-annotation can be merged to a @BindData-annotation. 
          The annotation must define a view type and what property to set. 
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/bind-data.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/bind-data.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Setup-->
    <div class="row">
      <div class="twelve columns">
        <h2>
          @Setup
        </h2>
        <p>
          The @Setup-annotation is used to declare bind methods that should only run once. Setup methods will always run before any bind methods.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/setup.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/setup.java %}
{% endhighlight %}
      </div>
    </div>
     <!-- BindNull-->
     <div class="row">
      <div class="twelve columns">
        <h2>
          @BindNull
        </h2>
        <p>
          The @BindNull-annotation enables null values to be used in bind methods. By default, null values are ignored.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/bindnull.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/bindnull.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- View holders built in -->
    <div class="row">
      <div class="twelve columns top-10">
        <h2>
          Adapter views
        </h2>
        <p>
          Witch will create view holders for all annotated views. This eliminates the need for creating additional 
          view holders for adapter views. <br/><br/> 
          
          <b>WitchRecyclerViewAdapter</b> makes it easy implement data bindings for a recycler view.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/recycler-view-binder.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/recycler-view-binder.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Post binder -->
    <div class="row top-10">
      <div class="twelve columns">
        <p>
          Binders must extend <b>WitchRecyclerViewAdapter.Binder</b>. In this case, the PostBinder will handle binding of 
          <b><i>all items of type Post</i></b> in the adapters data set. For each position, the binder will be updated 
          with the corresponding data item that will be accassible through the magical property <b>item</b> and should 
          only be reference from within a bind method.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/post-binder.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/post-binder.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Multiple binders -->
    <div class="row top-10">
      <div class="twelve columns">
        <p>
          Multiple data types are supported by simply providing multiple binders to the adapter.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/multiple-binders.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/multiple-binders.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Bind order -->
    <div class="row">
      <div class="twelve columns">
        <h2>
          Bind order
        </h2>
        <p>
          Data is bound in same order as the <i>bind methods</i> are defined.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/bind-order.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/bind-order.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Simple bind control -->
    <div class="row">
      <div class="twelve columns">
        <h2>
          Bind control
        </h2>
        <p>
          From a performance perspective, it is important that views are not updated unnecessarily. 
          Updating views can cause chains of measure and layout passes and should be avoided if possible. 
          Witch is designed to only bind data that has changed since last bind pass. Besides positive effect on performance, 
          this alows for things like animations to be executed from bind methods with no risk of running when data has not changed. 
          <br/><br/>
          This behaviour can be altered by using the <b>@BindWhen</b> annotation.
          The default strategy for all values is <b>BindWhen.NOT_EQUALS</b> described below.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin twelve columns">
{% highlight kotlin linenos %}
{% include snippets/bind-when.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java twelve columns">
{% highlight java linenos %}
{% include snippets/bind-when.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Debugging -->
    <div class="row top-10">
      <div class="twelve columns">
        <h2>
          Debugging
        </h2>
        <p>
          Enable logging to get readable representations of all targets when bound.
        </p>
      </div>
    </div>
    <div class="row code-container">
      <div class="code kotlin">
{% highlight kotlin linenos %}
{% include snippets/logging.kotlin %}
{% endhighlight %}
      </div>
      <div class="code java">
{% highlight java linenos %}
{% include snippets/logging.java %}
{% endhighlight %}
      </div>
    </div>
    <!-- Install -->
    <div class="row" id="install">
      <div class="twelve columns">
        <h2>
          Gradle
        </h2>
      </div>
    </div>
    <div class="row top-10 code-container">
      <div class="code java">
{% highlight gradle linenos %}
{% include snippets/download-java.gradle %}
{% endhighlight %}
      </div>
      <div class="code kotlin">
{% highlight gradle linenos %}
{% include snippets/download-kotlin.gradle %}
{% endhighlight %}
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">
  $(document).ready(function() {
    $("body").css("display", "block");
  });
</script>
